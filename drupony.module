<?php

use Drupony\Drupony;
use Symfony\Component\Filesystem\Filesystem;

/**
 * Tries to include the autoloader.
 * @see _drupony_find_composer_autoloader_dir().
 * No-op if it was already included or our main class exists (external autoloader)
 *
 * @throws RuntimeException If our main class and autoloader don't exist.
 */
function drupony_autload() {
  static $loaded;
  if ($loaded) return;
  $loaded = TRUE;
  if (class_exists('Drupony\\Drupony')) {
    return;
  }

  $autoloader = variable_get('drupony_autoloader');
  if (!isset($autoloader) || !file_exists($autoloader)) {
    $autoloader = _drupony_find_composer_autoloader_dir() . DIRECTORY_SEPARATOR . 'autoload.php';
    variable_set('drupony_autoloader', $autoloader);
  }

  require_once $autoloader;
}

/**
 * Starts looking for a vendor dir inside $min and keeps moving up until it reaches $max,
 * Unless a vendor dir containing autoload.php is found.
 *
 * @param string $min The directory path to start the search in.
 * @param string $max The highest directory level, once reached searching will stop.
 * @return string The directory the autoloader resides in.
 *
 * @throws RuntimeException If no autoloader was found.
 */
function _drupony_find_composer_autoloader_dir($min = __DIR__, $max = DRUPAL_ROOT) {
  $limit = strlen(realpath($max));
  while (($min = realpath($min)) && strlen($min) >= $limit) {
    $dir = $min . DIRECTORY_SEPARATOR . 'vendor';
    if (is_dir($dir) && file_exists($dir . DIRECTORY_SEPARATOR . 'autoload.php') && is_dir($dir . DIRECTORY_SEPARATOR . 'composer')) {
      return $dir;
    }
    $min .= DIRECTORY_SEPARATOR . '..';
  }

  throw new \RuntimeException(sprintf('Composer autoloader could not be found'));
}

function drupony_get_cache_dir($type = 'container') {
  $dir = variable_get('drupony_cachedir', __DIR__ . DIRECTORY_SEPARATOR . 'cache') . '\\' . $type;
  return preg_replace('/(\\\|\\/)+/', DIRECTORY_SEPARATOR, rtrim(trim($dir), '\\/'));
}

function drupony_clear_cache($type) {
  drupony_autload();
  $filesystem = new Filesystem();
  $filesystem->remove(drupony_get_cache_dir($type));
}

/**
 * Returns the default Drupony instance.
 *
 * @param bool $dev TRUE:  the container-cache monitors file changes.
 *                  FALSE: the container is cached once and requires a delete before it is refreshed.
 *                  - @see Symfony\Component\Config\ConfigCache
 * @return Drupony
 */
function drupony_get_wrapper($dev = FALSE) {
  static $drupony;
  if (isset($drupony)) {
    return $drupony;
  }
  drupony_autload();
  $cacheDir = drupony_get_cache_dir('container') . DIRECTORY_SEPARATOR . sha1(conf_path(FALSE));
  return new Drupony($cacheDir, $dev ? Drupony::CACHE_CHANGE : Drupony::CACHE_FULL, 'Main');
}

/**
 * Implements hook_flush_caches().
 */
function drupony_flush_caches() {
  drupony_clear_cache('container');
}

/**
 * Implements hook_admin_menu_cache_info
 */
function drupony_admin_menu_cache_info() {
  $caches = array();
  $caches['drupony'] = array(
    'title' => t('Drupony'),
    'callback' => 'drupony_flush_caches',
  );
  return $caches;
}
